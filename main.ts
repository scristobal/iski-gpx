import { BaseBuilder, buildGPX } from "npm:gpx-builder";
import { z } from "npm:zod";

const BUDDY_ID = "";
const COOKIE = "";
const AUTH = "";

/**
 * First and foremost, get the buddy_id, cookie and auth headers.
 *
 * Get all tracks by sending an authenticated GET request to
 * `https://delphi.iski.cc/api/tracks_list_v3.json?buddy_id=<buddy-id>&lang=en&selected_season=all`
 *
 * inside data._embedded.tracks, two options, either it has the shared or share field:
 *
 *  a) if .shared exists it means it was already shared and href can be used to retreive the id of the geometry
 *      { "shared": { "href": "https://delphi.iski.cc/tracks/shared/<share-id>" },
 *
 *  b) if .share existes it means it was never shared and the link needs to be generated by sending a POST request to href
 *      { "share": {"href": "https://delphi.iski.cc/api/tracks/<track-id>/share.json"},
 *      with an authentication header, eg. Authorization: <tokens>
 *
 *      the response would be similar to a)
 *      { "share_link": "https://share.iski.cc/shares/share_iski/tracks/<share-id>?lang=en" }
 *
 *  only the ID in the shared link is necesary to make a GET request (without authentication headers) to:
 *    https://share.iski.cc/shares/share_iski_analytics/tracks/g2MyzUxW7yMVfdVsvqY2/geometry.json?lang=en
 *
 *  the GET endpoint will reply with geopath data (time is in milliseconds since midnight local time)
 *  { "path": [ {"lat", "lng", "time", "elevation"}, ]}
 *
 *  if the options above fail, there is still an oportunity of recovering a low resolution version of the track by
 *    sending a POST resquest with authentication header to
 *    https://delphi.iski.cc/api/tracks/<track-id>/details?lang=en
 *
 *  it will return a field "track" containing the data with format is <point> <point> <point> ..
 *  being point = <lng_deg>,<lat_deg>,<elevation_m>,<time_epoch_ms>
 */

const headers = {
  "Authorization": AUTH,
  "Origin": "https://iski.cc",
  "Referer": "https://iski.cc/",
  "Cookie": COOKIE,
};

const shareLinkSchema = z.object({
  share_link: z.string(),
});

async function fetchShareId(track: Track) {
  try {
    // eg. "https://delphi.iski.cc/tracks/shared/<share-id>"

    const sharedLink = track._links.shared?.href;

    if (sharedLink !== undefined) return sharedLink;

    // eg. "https://delphi.iski.cc/api/tracks/<track-id>/share.json"
    const share = track._links.share?.href;

    if (!share) {
      throw `no share/d links (${track._links}).`;
    }

    const resp = await fetch(share, { method: "POST", headers });

    const json = await resp.json();

    const { share_link: shareLink } = shareLinkSchema.parse(json);

    //eg. "https://share.iski.cc/shares/share_iski/tracks/<share-id>?lang=en"
    const shareId = shareLink.split("?").at(0)?.split("/").at(-1);

    if (typeof shareId === "undefined") {
      throw `wrong share_link (${sharedLink}).`;
    }

    return shareId;
  } catch (e) {
    throw `can't fetch share id ${e}`;
  }
}

async function fetchHighresGeoPath(track: Track) {
  try {
    const shareId = await fetchShareId(track);
    const url =
      `https://share.iski.cc/shares/share_iski_analytics/tracks/${shareId}/geometry.json?lang=en`;

    const resp = await fetch(url, { method: "GET" });

    const data = await resp.json();

    const path = geoPathSchema.parse(data);

    return path;
  } catch (e) {
    throw `can't fetch high resolution ${e}`;
  }
}

async function fetchLowresGeoPath(track: Track) {
  try {
    const url = `https://delphi.iski.cc/api/tracks/${track.id}/details?lang=en`;

    const res = await fetch(url, { method: "GET", headers });

    const details = await res.json();

    const trackSchema = z.object({ track: z.string() });

    const { track: trackDetails } = trackSchema.parse(details);

    const path: GeoPath["path"] = [];

    for (const point of trackDetails.split(" ")) {
      const data = point.split(",");

      path.push({
        lng: parseFloat(data[0]),
        lat: parseFloat(data[1]),
        elevation: parseInt(data[2]),
        time: parseInt(data[3]),
      });
    }

    return { path };
  } catch (e) {
    throw `can't fetch low resolution ${e}`;
  }
}

const geoPathSchema = z.object({
  path: z.object({
    lat: z.number(),
    lng: z.number(),
    time: z.number(),
    elevation: z.number(),
  }).array(),
});

type GeoPath = z.infer<typeof geoPathSchema>;

async function fetchGeoPath(track: Track) {
  try {
    return await fetchHighresGeoPath(track);
  } catch {
    console.warn(`Track ${track.id} has no high resolition data.`);
    try {
      return await fetchLowresGeoPath(track);
    } catch (e) {
      throw `low res path fetching ${e}`;
    }
  }
}

async function generateGPXFile(track: Track) {
  const startDate = new Date(track.startdate);

  try {
    const data = await fetchGeoPath(track);

    const { Point } = BaseBuilder.MODELS;

    const segment = [];

    const startDateEpochMs = startDate.getTime();
    const startDeltaTimeMs = data.path.at(0)?.time;

    if (!startDeltaTimeMs) throw `path without elements.`;

    for (const point of data.path) {
      const time = new Date(startDateEpochMs + point.time - startDeltaTimeMs);

      segment.push(
        new Point(point.lat, point.lng, { ele: point.elevation, time }),
      );
    }

    const gpxData = new BaseBuilder();

    gpxData.setSegmentPoints(segment);

    return buildGPX(gpxData.toObject());
  } catch (e) {
    throw `can't generate GPX ${e}`;
  }
}

function isGPXSaved(track: Track) {
  try {
    return Deno.statSync(`track_${track.id}.gpx`).isFile;
  } catch {
    return false;
  }
}

const trackSchema = z.object({
  id: z.string(),
  startdate: z.string().date(),
}).and(
  z.object({
    _links: z.object({
      share: z.object({ href: z.string() }).optional(),
      shared: z.object({ href: z.string() }).optional(),
    }),
  }),
);

type Track = z.infer<typeof trackSchema>;

const trackListSchema = z.object({
  _embedded: z.object({
    tracks: trackSchema.array(),
  }),
});

if (import.meta.main) {
  const resp = await fetch(
    `https://delphi.iski.cc/api/tracks_list_v3.json?buddy_id=${BUDDY_ID}&lang=en&selected_season=all`,
    { method: "GET", headers },
  );

  const json = await resp.json();

  const data = trackListSchema.parse(json);

  const totalNum = data._embedded.tracks.length;

  for (const [ind, track] of data._embedded.tracks.entries()) {
    if (isGPXSaved(track)) {
      console.info(`${track.id}: already processed.`);
      continue;
    }

    console.info(`${track.id} : start processing.`);

    try {
      const gpx = await generateGPXFile(track);
      await Deno.writeTextFile(`track_${track.id}.gpx`, gpx);
      console.log(`${track.id}: proccessed ${ind}/${totalNum}`);
    } catch (e) {
      console.error(`ERROR ${track.id}: proccessing ${e}`);
    }
  }
}
